; ======================================================================
; Morley's Theorem - Generic Triangle (linear-algebraic trig thirds)
; ----------------------------------------------------------------------
; Polynomial-only encoding. Uses cos/sin for third-angles with triple-angle
; identities, encodes angle sum A+B+C=pi, solves trisector intersections as
; 2x2 linear systems, and enforces equilateral via the rotation identity
; R(pi/3)(P-Q) = R-Q. A symbolic r3 satisfies r3^2=3 for sin(pi/3).
; Triangle: B = (0,0), C = (1,0), A = (ax, ay) with 0 < ax < 1, ay > 0.
; ======================================================================

:verbose
:set-timeout 120
; Basic assumptions
:assume (> ay 0)
:assume (> ax 0)
:assume (< ax 1)

; Side lengths (symbolic) to avoid square roots
:assume (= lAB2 (+ (^ ax 2) (^ ay 2)))                    ; |AB|^2
:assume (= lAC2 (+ (^ (- 1 ax) 2) (^ ay 2)))              ; |AC|^2
:assume (= (^ lAB 2) lAB2)
:assume (= (^ lAC 2) lAC2)
:assume (> lAB 0)
:assume (> lAC 0)

; Cos/sin of full angles via dot/cross with lengths
; Angle B between BC (1,0) and BA (ax,ay)
:assume (= (* cosB lAB) ax)
:assume (= (* sinB lAB) ay)
:assume (= 1 (+ (^ cosB 2) (^ sinB 2)))

; Angle C between CB (-1,0) and CA (ax-1, ay)
:assume (= (* cosC lAC) (- 1 ax))
:assume (= (* sinC lAC) ay)
:assume (= 1 (+ (^ cosC 2) (^ sinC 2)))

; Angle A between AC (1-ax,-ay) and AB (-ax,-ay)
:assume (= (* cosA lAB lAC) (+ (* -1 ax) (^ ax 2) (^ ay 2)))
:assume (= (* sinA lAB lAC) ay)
:assume (= 1 (+ (^ cosA 2) (^ sinA 2)))

; Angle sum: A+B+C = pi  => cos(A+B) = -cosC, sin(A+B) = sinC
:assume (= (- (* cosA cosB) (* sinA sinB)) (* -1 cosC))
:assume (= (+ (* sinA cosB) (* cosA sinB)) sinC)

; Third-angles: unit-circle constraints
:assume (= 1 (+ (^ cB3 2) (^ sB3 2)))
:assume (= 1 (+ (^ cC3 2) (^ sC3 2)))
:assume (= 1 (+ (^ cA3 2) (^ sA3 2)))

; Triple-angle relations: cos(3θ)=4c^3-3c, sin(3θ)=3s-4s^3
:assume (= cosB (+ (* 4 (^ cB3 3)) (* -3 cB3)))
:assume (= sinB (+ (* 3 sB3) (* -4 (^ sB3 3))))
:assume (= cosC (+ (* 4 (^ cC3 3)) (* -3 cC3)))
:assume (= sinC (+ (* 3 sC3) (* -4 (^ sC3 3))))
:assume (= cosA (+ (* 4 (^ cA3 3)) (* -3 cA3)))
:assume (= sinA (+ (* 3 sA3) (* -4 (^ sA3 3))))

; Double-angle helpers for second trisectors
:assume (= cB2 (+ (^ cB3 2) (* -1 (^ sB3 2))))
:assume (= sB2 (* 2 cB3 sB3))
:assume (= cC2 (+ (^ cC3 2) (* -1 (^ sC3 2))))
:assume (= sC2 (* 2 cC3 sC3))
:assume (= cA2 (+ (^ cA3 2) (* -1 (^ sA3 2))))
:assume (= sA2 (* 2 cA3 sA3))

; Direction vectors for trisectors (un-normalized)
; B: rotate BC (1,0) by B/3 and 2B/3
:assume (= dirB1x cB3)
:assume (= dirB1y sB3)
:assume (= dirB2x cB2)
:assume (= dirB2y sB2)

; C: rotate CB (-1,0) by C/3 and 2C/3
:assume (= dirC1x (* -1 cC3))
:assume (= dirC1y (* -1 sC3))
:assume (= dirC2x (* -1 cC2))
:assume (= dirC2y (* -1 sC2))

; A: rotate AC (1-ax, -ay) by A/3 and 2A/3
:assume (= dirA1x (+ (* (- 1 ax) cA3) (* ay sA3)))
:assume (= dirA1y (+ (* (- 1 ax) sA3) (* -1 ay cA3)))
:assume (= dirA2x (+ (* (- 1 ax) cA2) (* ay sA2)))
:assume (= dirA2y (+ (* (- 1 ax) sA2) (* -1 ay cA2)))

; Intersection P near BC solved via determinant (eliminate parameters)
:assume (= detBC (+ (* -1 dirB1x dirC1y) (* dirC1x dirB1y)))
:assume (> (^ detBC 2) 0)
:assume (= 0 (+ (* px detBC) (* dirC1y dirB1x)))
:assume (= 0 (+ (* py detBC) (* dirC1y dirB1y)))

; Intersection Q near CA: C + qC*dirC2 = A + qA*dirA1, keep params but link with det
:assume (= detCA (+ (* -1 dirC2x dirA1y) (* dirC2y dirA1x)))
:assume (> (^ detCA 2) 0)
:assume (= qx (+ 1 (* qC dirC2x)))
:assume (= qy (* qC dirC2y))
:assume (= 0 (+ (* detCA qC) (* -1 (- ax 1) dirA1y) (* ay dirA1x)))
:assume (= 0 (+ (* detCA qA) (* dirC2x ay) (* -1 dirC2y (- ax 1))))
:assume (= qx (+ ax (* qA dirA1x)))
:assume (= qy (+ ay (* qA dirA1y)))
:assume (> qC 0)
:assume (> qA 0)

; Intersection R near AB: A + rA*dirA2 = B + rB*dirB2
:assume (= detAB (+ (* dirA2x dirB2y) (* -1 dirA2y dirB2x))) ; det of [dirA2 -dirB2]
:assume (> (^ detAB 2) 0)
:assume (= rx (+ ax (* rA dirA2x)))
:assume (= ry (+ ay (* rA dirA2y)))
:assume (= 0 (+ (* detAB rA) (* -1 ax dirB2y) (* ay dirB2x)))
:assume (= 0 (+ (* detAB rB) (* dirA2x ay) (* -1 dirA2y ax)))
:assume (= rx (* rB dirB2x))
:assume (= ry (* rB dirB2y))
:assume (> rA 0)
:assume (> rB 0)

; Equilateral condition via rotation by 60 degrees:
; r3 is symbolic sqrt(3): r3^2 = 3, r3 > 0.
:assume (= (^ r3 2) 3)
:assume (> r3 0)
; Equilateral encoded as rotation by +60deg of (P-Q) equals (R-Q):
; 2*(R-Q) = (P-Q) + r3 * rot90(P-Q)
:assume (= eq60x (+ (* 2 (- rx qx)) (* -1 (- px qx)) (* r3 (- py qy))))
:assume (= eq60y (+ (* 2 (- ry qy)) (* -1 (- py qy)) (* -1 r3 (- px qx))))
:prove (= eq60x 0)
:prove (= eq60y 0)
