-- Stress Test: Recursive Macros and Compile-Time Logic

:verbose

-- 1. Arithmetic Recursion: Triangle Numbers
-- Computes sum 1..n
:macro tri n = (if (= n 0) 0 (+ n (tri (- n 1))))

-- Verify tri(15) = 120
(= (tri 15) 120)


-- 2. Logic Recursion: Even/Odd Check
-- Returns 1 if even, 0 if odd
:macro is_even n = (if (= n 0) 1 (if (= n 1) 0 (is_even (- n 2))))

(= (is_even 20) 1)
(= (is_even 21) 0)


-- 3. Geometric Recursion: Chebyshev Polynomials of the First Kind
-- T(0, x) = 1
-- T(1, x) = x
-- T(n, x) = 2x * T(n-1, x) - T(n-2, x)
-- This generates high-degree polynomials rapidly.

:macro T n x = (if (= n 0) 1 (if (= n 1) x (- (* 2 (* x (T (- n 1) x))) (T (- n 2) x))))

-- Define a point to provide a variable 'x'
:point A 0 0
:point B 2 0
-- Let x = dist2(A, B) = 4

-- Calculate T(3, 4)
-- T(0,4)=1, T(1,4)=4
-- T(2,4) = 2*4*4 - 1 = 31
-- T(3,4) = 2*4*31 - 4 = 248 - 4 = 244
(= (T 3 (dist2 A B)) 244)

-- Calculate T(4, x) where x=3 (Point C)
:point C 3 0
-- dist2(A, C) = 9. Wait, sqrt(9)=3. dist2 is 9.
-- Let's use x = (dist2 A B) / 4 * 3 = 3? No, arithmetic on expressions is symbolic.
-- Let's just trust the prover algebra.
-- T(4, x) = 8x^4 - 8x^2 + 1
-- We check if the macro expands to the correct polynomial structure by proving it against the explicit form.
-- Note: The prover handles polynomial equality.
:point P x 0
(= (T 4 x) (+ (- (* 8 (^ x 4)) (* 8 (^ x 2))) 1))


-- 4. Deep Recursion
-- Tests the recursion depth limit (set to 100)
:macro deep n = (if (= n 0) 0 (+ 1 (deep (- n 1))))
(= (deep 50) 50)

:list
