<!DOCTYPE html>
<html>
<head>
    <title>Hasclid: Geometric Theorem Prover</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.2.1/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.2.1/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.js"></script>

    <style>
        body { margin: 0; background: #000; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        #terminal { flex: 1; padding: 10px; }
        #header {
            position: absolute; top: 10px; right: 20px; z-index: 10;
            color: #444; font-family: monospace; font-size: 12px; pointer-events: none;
        }
        a { color: #666; text-decoration: none; pointer-events: auto; }
        a:hover { color: #888; }
    </style>
</head>
<body>
    <div id="header">Hasclid v7.2 (Web) | <a href="https://github.com/TACITVS/Hasclid">Source</a></div>
    <div id="terminal"></div>

    <script type="module">
        // Reactor-mode WASM - no blocking I/O, just function calls!
        async function main() {
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 16,
                fontFamily: 'Consolas, "Courier New", monospace',
                theme: { background: '#000000', foreground: '#f0f0f0' }
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => fitAddon.fit());

            term.write('\x1b[32m[System] Loading Hasclid Engine...\x1b[0m\r\n');

            try {
                // Fetch WASM binary
                const response = await fetch('Euclid.wasm');
                if (!response.ok) throw new Error(`Failed to load Euclid.wasm (${response.status})`);

                const bytes = await response.arrayBuffer();
                term.write(`\x1b[33m[Debug] Loaded ${bytes.byteLength} bytes\x1b[0m\r\n`);

                // Instantiate WASM in reactor mode (no main(), just exported functions)
                term.write('\x1b[33m[Debug] Instantiating WASM module...\x1b[0m\r\n');

                // Memory helpers for FFI
                const memory = new WebAssembly.Memory({ initial: 256, maximum: 512 });
                const importObject = {
                    env: {
                        memory: memory
                    }
                };

                const { instance } = await WebAssembly.instantiate(bytes, importObject);
                term.write('\x1b[32m[System] WASM module loaded successfully!\x1b[0m\r\n');

                // Access exported functions
                const prover_init = instance.exports.prover_init;
                const prover_execute = instance.exports.prover_execute;
                const malloc = instance.exports.malloc || instance.exports._malloc;
                const free = instance.exports.free || instance.exports._free;
                const wasm_memory = instance.exports.memory;

                // Helper: Write JS string to WASM memory
                function writeString(str) {
                    const encoder = new TextEncoder();
                    const bytes = encoder.encode(str + '\0'); // null-terminated
                    const ptr = malloc(bytes.length);
                    const mem = new Uint8Array(wasm_memory.buffer, ptr, bytes.length);
                    mem.set(bytes);
                    return ptr;
                }

                // Helper: Read C string from WASM memory
                function readString(ptr) {
                    const mem = new Uint8Array(wasm_memory.buffer);
                    let end = ptr;
                    while (mem[end] !== 0) end++;
                    const bytes = mem.subarray(ptr, end);
                    return new TextDecoder().decode(bytes);
                }

                // Initialize the prover
                term.write('\x1b[33m[Debug] Initializing prover...\x1b[0m\r\n');
                const initPtr = prover_init();
                const banner = readString(initPtr);
                free(initPtr);

                // Display banner
                term.write('\r\n');
                term.write(banner.replace(/\n/g, '\r\n'));
                term.write('\r\n');

                // Setup input handling
                let inputBuffer = "";

                function showPrompt() {
                    term.write('\x1b[32mEuclid> \x1b[0m');
                }

                showPrompt();

                term.onData(data => {
                    if (data === '\r') { // Enter
                        term.write('\r\n');

                        // Execute command via WASM
                        const cmdPtr = writeString(inputBuffer);
                        const resultPtr = prover_execute(cmdPtr);
                        const result = readString(resultPtr);

                        // Free memory
                        free(cmdPtr);
                        free(resultPtr);

                        // Display result
                        if (result.length > 0) {
                            term.write(result.replace(/\n/g, '\r\n'));
                            term.write('\r\n');
                        }

                        // Check for exit commands
                        if (inputBuffer === 'exit' || inputBuffer === 'quit' || inputBuffer === ':q') {
                            term.write('\x1b[33m\r\nSession ended. Refresh to restart.\x1b[0m\r\n');
                            return;
                        }

                        inputBuffer = "";
                        showPrompt();

                    } else if (data === '\u007F') { // Backspace
                        if (inputBuffer.length > 0) {
                            inputBuffer = inputBuffer.slice(0, -1);
                            term.write('\b \b');
                        }
                    } else if (data >= ' ' || data === '\t') { // Printable characters
                        inputBuffer += data;
                        term.write(data);
                    }
                });

                term.write('\x1b[32m[System] Ready! Type :help for commands.\x1b[0m\r\n\r\n');

            } catch (e) {
                term.write(`\r\n\x1b[31m[Critical Error] ${e.message}\x1b[0m\r\n`);
                console.error(e);
            }
        }

        main();
    </script>
</body>
</html>
