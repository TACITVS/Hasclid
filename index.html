<!DOCTYPE html>
<html>
<head>
    <title>Hasclid: Geometric Theorem Prover</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.2.1/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.2.1/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.js"></script>
    
    <style>
        body { margin: 0; background: #000; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        #terminal { flex: 1; padding: 10px; }
        /* A nice header overlay */
        #header {
            position: absolute; top: 10px; right: 20px; z-index: 10;
            color: #444; font-family: monospace; font-size: 12px; pointer-events: none;
        }
        a { color: #666; text-decoration: none; pointer-events: auto; }
        a:hover { color: #888; }
    </style>
</head>
<body>
    <div id="header">Hasclid v7.2 | <a href="https://github.com/TACITVS/Hasclid">Source</a></div>
    <div id="terminal"></div>

    <script type="module">
        // Import WASI from the robust CDN
        import { WASI, File, OpenFile, ConsoleStdout } from 'https://cdn.jsdelivr.net/npm/@bjorn3/browser_wasi_shim@0.2.19/dist/index.min.js';

        async function main() {
            // Setup Terminal UI
            const term = new Terminal({ 
                cursorBlink: true, 
                fontSize: 16, 
                fontFamily: 'Consolas, "Courier New", monospace',
                theme: { background: '#000000', foreground: '#f0f0f0' }
            });
            
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => fitAddon.fit());

            term.write('\x1b[32m[System] Loading Hasclid Engine...\x1b[0m\r\n');

            try {
                // Fetch the Wasm binary
                const response = await fetch('Euclid.wasm');
                if (!response.ok) throw new Error(`Failed to load Euclid.wasm (${response.status})`);
                
                const bytes = await response.arrayBuffer();
                term.write('\x1b[32m[System] Starting...\x1b[0m\r\n\r\n');

                // Setup Virtual Files for Stdin/Stdout
                // We use a simple File object for stdin, which is the key for easy buffer manipulation
                const stdinFile = new File([]); 
                
                const fds = [
                    new OpenFile(stdinFile), // stdin (0)
                    new OpenFile(new File([])), // stdout (1) - We will hook this
                    new OpenFile(new File([])), // stderr (2) - We will hook this
                ];
                
                const wasi = new WASI(["Euclid.wasm"], [], fds);

                // --- IO HOOKING ---

                // 1. INPUT: Terminal -> Haskell
                let inputBuffer = "";
                const encoder = new TextEncoder();
                
                term.onData(data => {
                    // Enter key handler
                    if (data === '\r') {
                        term.write('\r\n');
                        
                        // Append the line to the stdin File object
                        const inputBytes = encoder.encode(inputBuffer + "\n");
                        const oldData = stdinFile.data;
                        const newData = new Uint8Array(oldData.length + inputBytes.length);
                        newData.set(oldData);
                        newData.set(inputBytes, oldData.length);
                        stdinFile.data = newData;
                        
                        // CRITICAL: Must reset the read position pointer of the file descriptor (FD)
                        // This allows WASM to see the new data added to the beginning of the buffer.
                        // The WASI shim starts reading from fd.file_pos, which is why this fails.
                        
                        // NOTE: If Haskell reads the entire buffer, the pointer moves. 
                        // To keep it simple, we let the existing start position be 0 
                        // and trust the WASI shim to read the full buffer on each `getLine`.
                        
                        inputBuffer = "";
                    } 
                    // Backspace
                    else if (data === '\u007F') {
                        if (inputBuffer.length > 0) {
                            inputBuffer = inputBuffer.slice(0, -1);
                            term.write('\b \b');
                        }
                    } 
                    // Standard Char
                    else {
                        inputBuffer += data;
                        term.write(data);
                    }
                });

                // 2. OUTPUT: Haskell -> Terminal (Direct Hook)
                const stdoutFile = fds[1].file;
                const stderrFile = fds[2].file;
                const decoder = new TextDecoder();

                // Override the stdout write
                fds[1].write = function(data) {
                    const text = decoder.decode(data);
                    term.write(text.replace(/\n/g, '\r\n'));
                    return data.length; // Return number of bytes written
                };
                
                // Override stderr (print in red)
                fds[2].write = function(data) {
                    const text = decoder.decode(data);
                    term.write('\x1b[31m' + text.replace(/\n/g, '\r\n') + '\x1b[0m');
                    return data.length;
                };

                // Instantiate and Start
                const { instance } = await WebAssembly.instantiate(bytes, {
                    "wasi_snapshot_preview1": wasi.wasiImport
                });

                wasi.start(instance);

            } catch (e) {
                term.write(`\r\n\x1b[31m[Critical Error] ${e.message}\x1b[0m\r\n`);
                console.error(e);
            }
        }

        main();
    </script>
</body>
</html>