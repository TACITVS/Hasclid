<!DOCTYPE html>
<html>
<head>
    <title>Hasclid: Geometric Theorem Prover</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.2.1/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.2.1/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.js"></script>
    
    <style>
        body { margin: 0; background: #000; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        #terminal { flex: 1; padding: 10px; }
        /* A nice header overlay */
        #header {
            position: absolute; top: 10px; right: 20px; z-index: 10;
            color: #444; font-family: monospace; font-size: 12px; pointer-events: none;
        }
        a { color: #666; text-decoration: none; pointer-events: auto; }
        a:hover { color: #888; }
    </style>
</head>
<body>
    <div id="header">Hasclid v7.2 | <a href="https://github.com/TACITVS/Hasclid">Source</a></div>
    <div id="terminal"></div>

    <script type="module">
        // Import WASI from the robust CDN
        import { WASI, File, OpenFile, ConsoleStdout } from 'https://cdn.jsdelivr.net/npm/@bjorn3/browser_wasi_shim@0.2.19/dist/index.min.js';

        async function main() {
            // Setup Terminal UI
            const term = new Terminal({ 
                cursorBlink: true, 
                fontSize: 16, 
                fontFamily: 'Consolas, "Courier New", monospace',
                theme: { background: '#000000', foreground: '#f0f0f0' }
            });
            
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal'));
            fitAddon.fit();
            window.addEventListener('resize', () => fitAddon.fit());

            term.write('\x1b[32m[System] Loading Hasclid Engine...\x1b[0m\r\n');

            try {
                // Fetch the Wasm binary
                term.write('\x1b[33m[Debug] Fetching Euclid.wasm...\x1b[0m\r\n');
                const response = await fetch('Euclid.wasm');
                if (!response.ok) throw new Error(`Failed to load Euclid.wasm (${response.status})`);

                const bytes = await response.arrayBuffer();
                term.write(`\x1b[33m[Debug] Loaded ${bytes.byteLength} bytes\x1b[0m\r\n`);
                term.write('\x1b[32m[System] Starting...\x1b[0m\r\n\r\n');

                // Setup Virtual Files for Stdin/Stdout
                // We use a simple File object for stdin, which is the key for easy buffer manipulation
                // IMPORTANT: Pre-populate stdin with a newline to prevent initial getLine from blocking
                const stdinFile = new File([new Uint8Array([10])]); // 10 = '\n' 
                
                const fds = [
                    new OpenFile(stdinFile), // stdin (0)
                    new OpenFile(new File([])), // stdout (1) - We will hook this
                    new OpenFile(new File([])), // stderr (2) - We will hook this
                ];
                
                const wasi = new WASI(["Euclid.wasm"], [], fds);

                // --- IO HOOKING ---

                // 1. INPUT: Terminal -> Haskell
                let inputBuffer = "";
                const encoder = new TextEncoder();
                
                term.onData(data => {
                    // Enter key handler
                    if (data === '\r') {
                        term.write('\r\n');

                        // Add input to stdin and RESET the file position
                        const inputBytes = encoder.encode(inputBuffer + "\n");

                        // Replace stdin data completely (don't append)
                        stdinFile.data = inputBytes;

                        // CRITICAL: Reset the read position to 0 so WASM can read the new input
                        fds[0].file_pos = 0;

                        inputBuffer = "";
                    } 
                    // Backspace
                    else if (data === '\u007F') {
                        if (inputBuffer.length > 0) {
                            inputBuffer = inputBuffer.slice(0, -1);
                            term.write('\b \b');
                        }
                    } 
                    // Standard Char
                    else {
                        inputBuffer += data;
                        term.write(data);
                    }
                });

                // 2. OUTPUT: Haskell -> Terminal (Direct Hook)
                const stdoutFile = fds[1].file;
                const stderrFile = fds[2].file;
                const decoder = new TextDecoder();

                // Override the stdout write
                fds[1].write = function(data) {
                    const text = decoder.decode(data);
                    term.write(text.replace(/\n/g, '\r\n'));
                    return data.length; // Return number of bytes written
                };
                
                // Override stderr (print in red)
                fds[2].write = function(data) {
                    const text = decoder.decode(data);
                    term.write('\x1b[31m' + text.replace(/\n/g, '\r\n') + '\x1b[0m');
                    return data.length;
                };

                // Instantiate and Start
                term.write('\x1b[33m[Debug] Instantiating WASM module...\x1b[0m\r\n');
                const { instance } = await WebAssembly.instantiate(bytes, {
                    "wasi_snapshot_preview1": wasi.wasiImport
                });

                term.write('\x1b[33m[Debug] Starting WASM instance...\x1b[0m\r\n');
                wasi.start(instance);
                term.write('\x1b[32m[Debug] WASM started successfully!\x1b[0m\r\n');

            } catch (e) {
                term.write(`\r\n\x1b[31m[Critical Error] ${e.message}\x1b[0m\r\n`);
                console.error(e);
            }
        }

        main();
    </script>
</body>
</html>